<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 声zzz</title>
    <link>http://reusee.github.io/post/</link>
    <description>Recent content in Posts on 声zzz</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 25 Oct 2015 09:32:00 +0800</lastBuildDate>
    
	<atom:link href="http://reusee.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>golang变量逃逸分析小探</title>
      <link>http://reusee.github.io/post/escape_analysis/</link>
      <pubDate>Sun, 25 Oct 2015 09:32:00 +0800</pubDate>
      
      <guid>http://reusee.github.io/post/escape_analysis/</guid>
      <description>看到这篇博文： http://www.zenlife.tk/go-allocated-on-heap-or-stack.md ，于是想深入探究一下。
既然fmt.Println会使a、b逃逸，println不会，那就先从fmt.Println入手。
把fmt.Println的相关源码复制到同一个文件内，以让编译器给出具体的逃逸分析报告。 就是src/fmt/print.go和src/fmt/format.go两个文件的内容。
用go tool compile -m生成报告，有几千行，分析之。
先找到定义a变量的那一行，然后往上看：
a.go:1272: reflect.t·2 escapes to heap a.go:1265: leaking param content: a a.go:1265: leaking param content: p a.go:1265: leaking param content: p a.go:1265: leaking param: p a.go:1265: leaking param content: a a.go:1268: (*pp).doPrint p.fmt does not escape a.go:1272: (*pp).doPrint &amp;reflect.i·2 does not escape a.go:1274: (*pp).doPrint p.buf does not escape a.go:1280: (*pp).doPrint p.buf does not escape a.go:150: (*pp).free ignoring self-assignment to p.buf a.</description>
    </item>
    
    <item>
      <title>go处理错误的另一种方式</title>
      <link>http://reusee.github.io/post/error-handling/</link>
      <pubDate>Thu, 01 Oct 2015 15:05:34 +0800</pubDate>
      
      <guid>http://reusee.github.io/post/error-handling/</guid>
      <description>go处理错误常见的方式是
err := funcReturningError() if err != nil { // 处理错误 }  然而因为过于繁琐而饱受诟病。下文简述另一种处理错误的写法。
这种写法最初我是从标准库里看到的，代码在 https://github.com/golang/go/blob/master/src/encoding/gob/error.go 。 简言之，就是将错误用panic抛出，然后在某个边界用defer将其转为error值。这和其他用抛异常来处理错误的语言类似。 不过上述代码并不十分通用，也没有解决最开始提出的写法繁琐的问题。 受其启发，我现在用得最多的错误处理方式是这样的 https://github.com/reusee/codes/blob/master/err/err.go 。
首先是Err结构体，定义如下
type Err struct { Pkg, Info string Err error }  Pkg用于标识抛出错误的包，Info是对错误的描述。Err用于包装另一个错误，一般是当前函数所调用的函数返回的，可以实现类似java的chained exception的机制，后面再细说。
另外有一个me函数（make error），用于包装error，实现很简单不提。
然后是ce函数（check error）
func ce(err error, info string) { if err != nil { panic(me(err, info)) } }  这个函数检查err参数是否为nil，如果不是，则包装出一个Err结构，然后用panic抛出。 这个就是用于替代if err != nil { &amp;hellip; }的了。
错误用panic抛出后，必须在某个边界recover，API不应该对外暴露panic，否则会和go社区整体的理念不合，自找烦恼。 负责这个的是ct函数（catch error）
func ct(err *error) { if p := recover(); p !</description>
    </item>
    
    <item>
      <title>用嵌入字段实现代码重用</title>
      <link>http://reusee.github.io/post/embedded/</link>
      <pubDate>Thu, 28 Aug 2014 14:37:17 +0800</pubDate>
      
      <guid>http://reusee.github.io/post/embedded/</guid>
      <description>对数据结构加锁机制的常用方式，是嵌入一个sync.Mutex或sync.RWMutex。
type Foo struct { sync.Mutex // ... other fields } f := new(Foo) f.Lock() // ... operations f.Unlock()  Foo嵌入了sync.Mutex，所以可以在Foo结构上直接调用Lock和Unlock方法。 但这不是个仅限于此的语法糖，Foo实际已经实现了sync.Locker接口，就好像是Foo自己定义了Lock和Unlock方法一样。 Foo结构可以用于任何需要sync.Locker的地方，例如
condition := sync.NewCond(new(Foo)) 这就类似于接口的默认实现(default implementation)。实现接口时，只需要嵌入一个实现了此接口的类型， 而不需要重新实现一遍方法，或者使用命名字段再包装出接口所需的方法。
当然这个和真正的默认实现机制是有区别的，方法里如果需要引用被嵌入的类型的字段，须要在构造嵌入字段时显式传入。 例如这个接口
type Named interface { PrintName() }  要提供一个Named接口的可以嵌入的实现NamedImpl，可以有以下的方法。其一
type Named interface { PrintName() GetName() string } type NamedImpl struct { named Named } func (n NamedImpl) PrintName() { fmt.Printf(&#34;name is %s\n&#34;, n.named.GetName()) } type Foo struct { NamedImpl Name string } func (f Foo) GetName() string { return f.</description>
    </item>
    
    <item>
      <title>一种对象结构</title>
      <link>http://reusee.github.io/post/object/</link>
      <pubDate>Mon, 12 May 2014 14:37:09 +0800</pubDate>
      
      <guid>http://reusee.github.io/post/object/</guid>
      <description>https://github.com/reusee/object
这是开发gotunnel-ng时使用过的一种结构。 觉得比较通用，例如可以用在多线程gui库里，所以重新实现了下。简单介绍之。
0) 基本结构 基本结构有两个，一个是Object，代表概念上的一个对象；另一个是Call，代表一次方法调用。类型声明如下
type Object struct { call func(*Call) signals map[string][]interface{} } type Call struct { object *Object what int signal string fun interface{} doneCond *sync.Cond done bool arg []interface{} ret interface{} }  1) 线程安全的状态读写 Object的Call方法接受一个func()类型的参数，这个closure会被包装成Call结构，并送入Object的calls管道内。
Object的主循环会读到这个Call，并在循环内执行此closure。
所以在同一时间，Object只会处理一个Call，将状态读写操作包装进去，就能保证线程安全。
并发计数器的例子
obj := &amp;struct { *Object i int }{ Object: New(), } n := 512 wg := new(sync.WaitGroup) wg.Add(n) for i := 0; i  在多线程环境下，obj.i++操作是不安全的。但Call方法能保证所有传入的closure在单一goroutine内顺序执行。所以上面的计数器能保证结果是512。
同样的效果，用锁也能实现，但Lock操作是阻塞的，实现不了下述的机制。</description>
    </item>
    
  </channel>
</rss>