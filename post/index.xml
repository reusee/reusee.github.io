<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 声zzz</title>
    <link>http://reusee.github.io/post/</link>
    <description>Recent content in Posts on 声zzz</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 04 Aug 2019 12:00:00 +0800</lastBuildDate>
    
	<atom:link href="http://reusee.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>再议错误处理</title>
      <link>http://reusee.github.io/post/error-handling-2/</link>
      <pubDate>Sun, 04 Aug 2019 12:00:00 +0800</pubDate>
      
      <guid>http://reusee.github.io/post/error-handling-2/</guid>
      <description>几年前写过一篇文章，讨论了一种处理错误的方式。 近几年，在不需要压榨性能，或者不需要做覆盖测试的场景里，我都会用这种更简短的方式。
所以，对于 try 提案，我是支持的，因为用 try 可以替代 panic / recover 实现隐式的 return，在性能方面有优势。 try 提案寿终正寝了，我是觉得可惜的。很多反对 try 提案的人，都不是出于技术性的原因，很多都是非理性的。 当然，技术性的缺陷也是有的，但我认为还没有严重到，连试验都不做就要放弃的地步。
说回前一篇文章所讨论的方式，最近其实也有改进，单独做了一个包：https://github.com/reusee/e
和以前的实现比较，有下述几个不同点：
首先，panic 抛出的，是经过包装的 thrownError 对象，而不是原先的 error 对象。 这样做的好处是，可以准确判断 recover 返回的，是不是由错误处理的 panic 抛出的对象。 以前的做法就比较粗放，很可能会将一些需要 panic 的对象，转化成了 error 返回值。
第二个不同是，error 类型可以有不同的实现。 check 和 catch 函数不再是全局函数，而是由一个构造函数返回，而这个构造函数的参数，是一个包装错误的函数。 构造函数的签名为
func New( makeErr MakeErr, ) ( check func(err error, args ...interface{}), catch func(errp *error, args ...interface{}), ) { type MakeErr = func(error, ...interface{}) error  这种设计，比起之前使用固定的 Error 类型，要更灵活。 因为不同的项目，使用的 Error 可能不同，应该允许项目自己实现 makeErr。</description>
    </item>
    
    <item>
      <title>给 interface{} 起别名</title>
      <link>http://reusee.github.io/post/empty-interface-aliasing/</link>
      <pubDate>Sun, 04 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>http://reusee.github.io/post/empty-interface-aliasing/</guid>
      <description>在 go 程序里，interface{} 是常用的类型。即使会加入泛型，它仍然有需要用到的地方，例如需要运行期反射的场景。
最近在新项目里我都会用到下面的别名定义
type ( any = interface{} dyn = interface{} )  any 表示任意类型，用于需要做 type assertion 的场景。 例如容器类型，或者枚举类型。用泛型可以替代 any。
dyn 表示动态类型，用于需要做 reflect 的场景。 这些场景是泛型不能替代的，例如动态调用、赋值等。
使用这些别名，一来比较简短，二来语义可以更清晰。
类型别名在另外一些场景，也可以起到简化代码的作用，例如
type M = map[string]any M 是 string 到 any 的映射，在写嵌套的结构的字面量时，可以让代码简洁一些
var jsonData = M{ &#34;foo&#34;: M{ &#34;bar&#34;: M{ &#34;baz&#34;: []M{ { &#34;quux&#34;: 42, }, }, }, }, &#34;ok&#34;: true, }  如果不用别名，而是用 map[string]interface{}，就相当冗长了。
虽然类型别名的初衷并不是简化代码，而是方便重构，但既然具备上面所述的几个优点，那就可以用。</description>
    </item>
    
    <item>
      <title>golang变量逃逸分析小探</title>
      <link>http://reusee.github.io/post/escape_analysis/</link>
      <pubDate>Sun, 25 Oct 2015 09:32:00 +0800</pubDate>
      
      <guid>http://reusee.github.io/post/escape_analysis/</guid>
      <description>看到这篇博文： http://www.zenlife.tk/go-allocated-on-heap-or-stack.md ，于是想深入探究一下。
既然fmt.Println会使a、b逃逸，println不会，那就先从fmt.Println入手。
把fmt.Println的相关源码复制到同一个文件内，以让编译器给出具体的逃逸分析报告。 就是src/fmt/print.go和src/fmt/format.go两个文件的内容。
用go tool compile -m生成报告，有几千行，分析之。
先找到定义a变量的那一行，然后往上看：
a.go:1272: reflect.t·2 escapes to heap a.go:1265: leaking param content: a a.go:1265: leaking param content: p a.go:1265: leaking param content: p a.go:1265: leaking param: p a.go:1265: leaking param content: a a.go:1268: (*pp).doPrint p.fmt does not escape a.go:1272: (*pp).doPrint &amp;reflect.i·2 does not escape a.go:1274: (*pp).doPrint p.buf does not escape a.go:1280: (*pp).doPrint p.buf does not escape a.go:150: (*pp).free ignoring self-assignment to p.buf a.</description>
    </item>
    
    <item>
      <title>go处理错误的另一种方式</title>
      <link>http://reusee.github.io/post/error-handling/</link>
      <pubDate>Thu, 01 Oct 2015 15:05:34 +0800</pubDate>
      
      <guid>http://reusee.github.io/post/error-handling/</guid>
      <description>go处理错误常见的方式是
err := funcReturningError() if err != nil { // 处理错误 }  然而因为过于繁琐而饱受诟病。下文简述另一种处理错误的写法。
这种写法最初我是从标准库里看到的，代码在 https://github.com/golang/go/blob/master/src/encoding/gob/error.go 。 简言之，就是将错误用panic抛出，然后在某个边界用defer将其转为error值。这和其他用抛异常来处理错误的语言类似。 不过上述代码并不十分通用，也没有解决最开始提出的写法繁琐的问题。 受其启发，我现在用得最多的错误处理方式是这样的 https://github.com/reusee/codes/blob/master/err/err.go 。
首先是Err结构体，定义如下
type Err struct { Pkg, Info string Err error }  Pkg用于标识抛出错误的包，Info是对错误的描述。Err用于包装另一个错误，一般是当前函数所调用的函数返回的，可以实现类似java的chained exception的机制，后面再细说。
另外有一个me函数（make error），用于包装error，实现很简单不提。
然后是ce函数（check error）
func ce(err error, info string) { if err != nil { panic(me(err, info)) } }  这个函数检查err参数是否为nil，如果不是，则包装出一个Err结构，然后用panic抛出。 这个就是用于替代if err != nil { &amp;hellip; }的了。
错误用panic抛出后，必须在某个边界recover，API不应该对外暴露panic，否则会和go社区整体的理念不合，自找烦恼。 负责这个的是ct函数（catch error）
func ct(err *error) { if p := recover(); p !</description>
    </item>
    
    <item>
      <title>用嵌入字段实现代码重用</title>
      <link>http://reusee.github.io/post/embedded/</link>
      <pubDate>Thu, 28 Aug 2014 14:37:17 +0800</pubDate>
      
      <guid>http://reusee.github.io/post/embedded/</guid>
      <description>对数据结构加锁机制的常用方式，是嵌入一个sync.Mutex或sync.RWMutex。
type Foo struct { sync.Mutex // ... other fields } f := new(Foo) f.Lock() // ... operations f.Unlock()  Foo嵌入了sync.Mutex，所以可以在Foo结构上直接调用Lock和Unlock方法。 但这不是个仅限于此的语法糖，Foo实际已经实现了sync.Locker接口，就好像是Foo自己定义了Lock和Unlock方法一样。 Foo结构可以用于任何需要sync.Locker的地方，例如
condition := sync.NewCond(new(Foo)) 这就类似于接口的默认实现(default implementation)。实现接口时，只需要嵌入一个实现了此接口的类型， 而不需要重新实现一遍方法，或者使用命名字段再包装出接口所需的方法。
当然这个和真正的默认实现机制是有区别的，方法里如果需要引用被嵌入的类型的字段，须要在构造嵌入字段时显式传入。 例如这个接口
type Named interface { PrintName() }  要提供一个Named接口的可以嵌入的实现NamedImpl，可以有以下的方法。其一
type Named interface { PrintName() GetName() string } type NamedImpl struct { named Named } func (n NamedImpl) PrintName() { fmt.Printf(&#34;name is %s\n&#34;, n.named.GetName()) } type Foo struct { NamedImpl Name string } func (f Foo) GetName() string { return f.</description>
    </item>
    
    <item>
      <title>一种对象结构</title>
      <link>http://reusee.github.io/post/object/</link>
      <pubDate>Mon, 12 May 2014 14:37:09 +0800</pubDate>
      
      <guid>http://reusee.github.io/post/object/</guid>
      <description>https://github.com/reusee/object
这是开发gotunnel-ng时使用过的一种结构。 觉得比较通用，例如可以用在多线程gui库里，所以重新实现了下。简单介绍之。
0) 基本结构 基本结构有两个，一个是Object，代表概念上的一个对象；另一个是Call，代表一次方法调用。类型声明如下
type Object struct { call func(*Call) signals map[string][]interface{} } type Call struct { object *Object what int signal string fun interface{} doneCond *sync.Cond done bool arg []interface{} ret interface{} }  1) 线程安全的状态读写 Object的Call方法接受一个func()类型的参数，这个closure会被包装成Call结构，并送入Object的calls管道内。
Object的主循环会读到这个Call，并在循环内执行此closure。
所以在同一时间，Object只会处理一个Call，将状态读写操作包装进去，就能保证线程安全。
并发计数器的例子
obj := &amp;struct { *Object i int }{ Object: New(), } n := 512 wg := new(sync.WaitGroup) wg.Add(n) for i := 0; i  在多线程环境下，obj.i++操作是不安全的。但Call方法能保证所有传入的closure在单一goroutine内顺序执行。所以上面的计数器能保证结果是512。
同样的效果，用锁也能实现，但Lock操作是阻塞的，实现不了下述的机制。</description>
    </item>
    
  </channel>
</rss>