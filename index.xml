<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>声zzz</title>
    <link>http://reusee.github.io/</link>
    <description>Recent content on 声zzz</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 01 Oct 2015 15:05:34 +0800</lastBuildDate>
    <atom:link href="http://reusee.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>go处理错误的另一种方式</title>
      <link>http://reusee.github.io/post/error-handling/</link>
      <pubDate>Thu, 01 Oct 2015 15:05:34 +0800</pubDate>
      
      <guid>http://reusee.github.io/post/error-handling/</guid>
      <description>&lt;p&gt;go处理错误常见的方式是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
err := funcReturningError()
if err != nil {
  // 处理错误
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而因为过于繁琐而饱受诟病。下文简述另一种处理错误的写法。&lt;/p&gt;

&lt;p&gt;这种写法最初我是从标准库里看到的，代码在 &lt;a href=&#34;https://github.com/golang/go/blob/master/src/encoding/gob/error.go。&#34;&gt;https://github.com/golang/go/blob/master/src/encoding/gob/error.go。&lt;/a&gt;
简言之，就是将错误用panic抛出，然后在某个边界用defer将其转为error值。这和其他用抛异常来处理错误的语言类似。
不过上述代码并不十分通用，也没有解决最开始提出的写法繁琐的问题。
受其启发，我现在用得最多的错误处理方式是这样的 &lt;a href=&#34;https://github.com/reusee/codes/blob/master/err/err.go。&#34;&gt;https://github.com/reusee/codes/blob/master/err/err.go。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先是Err结构体，定义如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
type Err struct {
  Pkg, Info string
  Err error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pkg用于标识抛出错误的包，Info是对错误的描述。Err用于包装另一个错误，一般是当前函数所调用的函数返回的，可以实现类似java的chained exception的机制，后面再细说。&lt;/p&gt;

&lt;p&gt;另外有一个me函数（make error），用于包装error，实现很简单不提。&lt;/p&gt;

&lt;p&gt;然后是ce函数（check error）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
func ce(err error, info string) {
  if err != nil {
    panic(me(err, info))
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数检查err参数是否为nil，如果不是，则包装出一个Err结构，然后用panic抛出。
这个就是用于替代if err != nil { &amp;hellip; }的了。&lt;/p&gt;

&lt;p&gt;错误用panic抛出后，必须在某个边界recover，API不应该对外暴露panic，否则会和go社区整体的理念不合，自找烦恼。
负责这个的是ct函数（catch error）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
func ct(err *error) {
  if p := recover(); p != nil {
    if e, ok := p.(error); ok {
      *err = e
    } else {
      panic(p)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为用到了recover，所以ct只能在defer函数里调用。它首先recover()，然后看是否是error，是则将其赋值到传入的*error处，否则重新panic抛出&lt;/p&gt;

&lt;p&gt;来看看它是如何减少代码的，以 &lt;a href=&#34;https://blog.golang.org/errors-are-values&#34;&gt;https://blog.golang.org/errors-are-values&lt;/a&gt; 的一段代码为例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
_, err = fd.Write(p0[a:b])
if err != nil {
  return err
}
_, err = fd.Write(p1[c:d])
if err != nil {
  return err
}
_, err = fd.Write(p2[e:f])
if err != nil {
  return err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用上述机制，可以写成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
defer ct(&amp;err)
_, err = fd.Write(p0[a:b])
ce(err, &#34;write p0&#34;)
_, err = fd.Write(p1[c:d])
ce(err, &#34;write p1&#34;)
_, err = fd.Write(p2[e:f])
ce(err, &#34;write p2&#34;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码没有那样繁琐了。&lt;/p&gt;

&lt;p&gt;另外还有一个好处是，因为Err包装了上一个错误，所以定位错误比较容易。例如下面程序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
package main

func foo() (err error) {
    defer ct(&amp;err)
    ce(bar(), &#34;call bar&#34;)
    return
}

func bar() (err error) {
    defer ct(&amp;err)
    ce(baz(), &#34;call baz&#34;)
    return
}

func baz() (err error) {
    return me(nil, &#34;baz&#34;)
}

func main() {
    if err := foo(); err != nil {
        panic(err)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;paniclog是这样的&lt;/p&gt;

&lt;pre&gt;
panic: foobar: call bar
foobar: call baz
foobar: baz
...
&lt;/pre&gt;

&lt;p&gt;可以看出最外层的error包含了直到最内层的信息，包括包名foobar（这里只用到一个包所以体现不出），比起直接将最内层的error往上抛，要直观得多。&lt;/p&gt;

&lt;p&gt;最后说说这种写法的缺点。首先是不论有无错误都调用recover，调用recover又要使用defer函数，所以性能会受到影响。
另外因为没有 if 语句了，做覆盖测试的话，区分不出两种case了。
所以这种写法并不适合所有场景。需要压榨性能时不用，需要做覆盖测试时不用。
适合的场景是对性能要求不高的，对正确性要求也不高的。
我会用在经常变的应用代码，或者百几十行的小程序，或者测试代码里。
基础的包，还是好好写 if err != nil { &amp;hellip; } 吧。&lt;/p&gt;

&lt;p&gt;以上ct、me、ce等函数都不是public的，因为我使用时，是用代码生成工具复制出来用的，不需要public。
用的代码生成工具是 &lt;a href=&#34;https://github.com/reusee/ccg&#34;&gt;https://github.com/reusee/ccg&lt;/a&gt; ，可能会有另外一篇博文说说这个。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>about</title>
      <link>http://reusee.github.io/about/</link>
      <pubDate>Thu, 01 Oct 2015 14:36:39 +0800</pubDate>
      
      <guid>http://reusee.github.io/about/</guid>
      <description></description>
    </item>
    
    <item>
      <title>用嵌入字段实现代码重用</title>
      <link>http://reusee.github.io/post/embedded/</link>
      <pubDate>Thu, 28 Aug 2014 14:37:17 +0800</pubDate>
      
      <guid>http://reusee.github.io/post/embedded/</guid>
      <description>&lt;p&gt;对数据结构加锁机制的常用方式，是嵌入一个sync.Mutex或sync.RWMutex。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
type Foo struct {
  sync.Mutex
  // ... other fields
}

f := new(Foo)
f.Lock()
// ... operations
f.Unlock()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Foo嵌入了sync.Mutex，所以可以在Foo结构上直接调用Lock和Unlock方法。
但这不是个仅限于此的语法糖，Foo实际已经实现了sync.Locker接口，就好像是Foo自己定义了Lock和Unlock方法一样。
Foo结构可以用于任何需要sync.Locker的地方，例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
condition := sync.NewCond(new(Foo))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就类似于接口的默认实现(default implementation)。实现接口时，只需要嵌入一个实现了此接口的类型，
而不需要重新实现一遍方法，或者使用命名字段再包装出接口所需的方法。&lt;/p&gt;

&lt;p&gt;当然这个和真正的默认实现机制是有区别的，方法里如果需要引用被嵌入的类型的字段，须要在构造嵌入字段时显式传入。
例如这个接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
type Named interface {
    PrintName()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要提供一个Named接口的可以嵌入的实现NamedImpl，可以有以下的方法。其一&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
type Named interface {
    PrintName()
    GetName() string
}

type NamedImpl struct {
    named Named
}

func (n NamedImpl) PrintName() {
    fmt.Printf(&#34;name is %s\n&#34;, n.named.GetName())
}

type Foo struct {
    NamedImpl
    Name string
}

func (f Foo) GetName() string {
    return f.Name
}

func main() {
    var f Foo
    f.Name = &#34;foo&#34;
    f.NamedImpl = NamedImpl{f}
    f.PrintName()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给Named接口增加一个GetName方法。虽然感觉有点多余但也算可行。&lt;/p&gt;

&lt;p&gt;其二，不增加接口方法，只传需要的数据的引用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
type Named interface {
    PrintName()
}

type NamedImpl struct {
    name *string
}

func (n NamedImpl) PrintName() {
    fmt.Printf(&#34;name is %s\n&#34;, *n.name)
}

type Foo struct {
    NamedImpl
    Name string
}

func main() {
  var f Foo
  f.Name = &#34;foo&#34;
  f.NamedImpl = NamedImpl{&amp;f.Name}
  f.PrintName()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其三，不使用引用，而是嵌入一个closure以获得所需数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
type Named interface {
    PrintName()
}

type NamedImpl func() string

func (n NamedImpl) PrintName() {
    fmt.Printf(&#34;name is %s\n&#34;, n())
}

type Foo struct {
    NamedImpl
    Name string
}

func main() {
    var f Foo
    f.Name = &#34;foo&#34;
    f.NamedImpl = func() string { return f.Name }
    f.PrintName()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上例子中，其他类型要实现Named接口，可以不实现PrintName方法，而是嵌入一个NamedImpl。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
func main() {
    b := struct {
        NamedImpl
        name string
    }{}
    b.name = &#34;bar&#34;
    b.NamedImpl = func() string { return b.name }
    b.PrintName()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就实现了代码的重用。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>一种对象结构</title>
      <link>http://reusee.github.io/post/object/</link>
      <pubDate>Mon, 12 May 2014 14:37:09 +0800</pubDate>
      
      <guid>http://reusee.github.io/post/object/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/reusee/object&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;https://github.com/reusee/object&#34;&gt;https://github.com/reusee/object&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这是开发&lt;a href=&#34;https://github.com/reusee/gotunnel-ng&#34; target=&#34;_blank&#34;&gt;gotunnel-ng&lt;/a&gt;时使用过的一种结构。
觉得比较通用，例如可以用在多线程gui库里，所以重新实现了下。简单介绍之。&lt;/p&gt;

&lt;h3 id=&#34;0-基本结构:64f69964068e81337a920d35b6c5158f&#34;&gt;0) 基本结构&lt;/h3&gt;

&lt;p&gt;基本结构有两个，一个是Object，代表概念上的一个对象；另一个是Call，代表一次方法调用。类型声明如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;
type Object struct {
    call    func(*Call)
    signals map[string][]interface{}
}

type Call struct {
    object   *Object
    what     int
    signal   string
    fun      interface{}
    doneCond *sync.Cond
    done     bool
    arg      []interface{}
    ret      interface{}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-线程安全的状态读写:64f69964068e81337a920d35b6c5158f&#34;&gt;1) 线程安全的状态读写&lt;/h3&gt;

&lt;p&gt;Object的Call方法接受一个func()类型的参数，这个closure会被包装成Call结构，并送入Object的calls管道内。&lt;br /&gt;
Object的主循环会读到这个Call，并在循环内执行此closure。&lt;br /&gt;
所以在同一时间，Object只会处理一个Call，将状态读写操作包装进去，就能保证线程安全。&lt;br /&gt;
并发计数器的例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;
obj := &amp;struct {
    *Object
    i int
}{
    Object: New(),
}

n := 512
wg := new(sync.WaitGroup)
wg.Add(n)
for i := 0; i &lt; n; i++ {
    go func() {
        obj.Call(func() {
            obj.i++
        }).Wait()
        wg.Done()
    }()
}
wg.Wait()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在多线程环境下，&lt;code&gt;obj.i++&lt;/code&gt;操作是不安全的。但Call方法能保证所有传入的closure在单一goroutine内顺序执行。所以上面的计数器能保证结果是512。&lt;/p&gt;

&lt;p&gt;同样的效果，用锁也能实现，但Lock操作是阻塞的，实现不了下述的机制。&lt;/p&gt;

&lt;h3 id=&#34;2-异步调用和future:64f69964068e81337a920d35b6c5158f&#34;&gt;2) 异步调用和future&lt;/h3&gt;

&lt;p&gt;Object的Call方法是异步的，也就是传入的closure不会立即执行，Call方法在将Call结构送入calls成员后返回。&lt;br /&gt;
Call方法返回送出的Call结构，Call结构有一个Wait方法。
调用该方法后，在closure执行完成之前会一直阻塞，也就是，Wait方法返回后，closure一定已经执行完成了。&lt;br /&gt;
Call结构还有个Get方法，可以获得closure的返回值（不支持多值）。Get方法会调用Wait方法。所以一个Call可以作为future使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;
// obj如上创建
call := obj.Call(func() interface{} {
    obj.i = 8
    return obj.i
})
fmt.Printf(&#34;%d\n&#34;, call.Get().(int))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回值使用interface{}类型，是为了避免使用reflect。性能差异太大，所以作此取舍。&lt;/p&gt;

&lt;h3 id=&#34;3-signal-slot机制:64f69964068e81337a920d35b6c5158f&#34;&gt;3) Signal/Slot机制&lt;/h3&gt;

&lt;p&gt;Object用Connect和Emit方法实现Signal/Slot机制。这是和GObject、Qt之类类似的。&lt;br /&gt;
Emit可以带一个任意类型的参数。之前的实现使用了reflect，支持任意个，但reflect对性能影响不小，于是作此限定。&lt;br /&gt;
Emit在Slot执行之前就返回，如果要等待Slot执行可以调用Emit返回的Call的Wait方法。&lt;br /&gt;
同理，Connect支持的closure也是两种，不带参数的和带参数的，类型都是interface{}，需要type assertion后使用。&lt;br /&gt;
closure返回一个bool值，为false时，closure只会执行一次。&lt;br /&gt;
例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;
// obj如上创建
obj.i = 5
obj.Connect(&#34;sig&#34;, func(i interface{}) bool {
    obj.i += i.(int)
    return true
})
obj.Connect(&#34;sig&#34;, func(i interface{}) bool {
    obj.i += i.(int) * 2
    return false // one-shot signal
})
obj.Emit(&#34;sig&#34;, 5).Wait()
fmt.Printf(&#34;%d\n&#34;, obj.i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出为20&lt;/p&gt;

&lt;h3 id=&#34;4-执行驱动:64f69964068e81337a920d35b6c5158f&#34;&gt;4) 执行驱动&lt;/h3&gt;

&lt;p&gt;Object的各种方法调用，都是靠goroutine来驱动。
一个goroutine对应一个Object，这是默认的驱动的做法。
除此之外还有一个goroutine对应n个Object的n:1驱动，和多个goroutine对应所有Object的n:m驱动。&lt;/p&gt;

&lt;p&gt;因为一个goroutine的内存开销至少是2k，所以对象多时对内存和调度器都会产生压力。
n:1和n:m驱动就是用于降低goroutine带来的开销的。但因为goroutine数量少于Object数量，所以调用多时可能对性能产生影响。
总之就是时间换空间。&lt;/p&gt;

&lt;p&gt;1:1驱动的性能最好，n:m次之，n:1再次之。但n:1的内存占用最小，n:m多一些，1:1最多。&lt;/p&gt;

&lt;p&gt;64bit机器上，1G内存，1:1驱动可以跑12万个Object，n:m驱动在n为2048时能跑200万左右，n:1驱动在n为128时能跑320万左右。对象多时，goroutine的内存占比不高，n的影响不大。&lt;/p&gt;

&lt;h3 id=&#34;5-调用性能:64f69964068e81337a920d35b6c5158f&#34;&gt;5) 调用性能&lt;/h3&gt;

&lt;p&gt;一次Call调用，需要创建Call结构，进出calls管道，执行closure，改变完成状态和广播，开销不小。
在我机器上空closure的Benchmark的结果是，Call并Wait是840 ns/op左右，Call不Wait是560 ns/op左右。
Emit调用的性能也在同一个数量级。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>